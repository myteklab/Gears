<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gears</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f0f1a;
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
        }

        /* Menu Bar */
        .menu-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: #1a1a2e;
            border-bottom: 1px solid #2d2d44;
            padding: 0 10px;
            height: 40px;
        }

        .menu-left {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .menu-item {
            position: relative;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: background 0.2s;
        }

        .menu-item:hover {
            background: #2d2d44;
        }

        .dropdown {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: #252538;
            border: 1px solid #3d3d5c;
            border-radius: 6px;
            min-width: 180px;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .menu-item:hover .dropdown {
            display: block;
        }

        .dropdown-item {
            padding: 10px 15px;
            cursor: pointer;
            font-size: 13px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .dropdown-item:hover {
            background: #3d3d5c;
        }

        .dropdown-item:first-child {
            border-radius: 5px 5px 0 0;
        }

        .dropdown-item:last-child {
            border-radius: 0 0 5px 5px;
        }

        .shortcut {
            color: #888;
            font-size: 11px;
        }

        .divider {
            height: 1px;
            background: #3d3d5c;
            margin: 5px 0;
        }

        /* Playback Controls */
        .playback-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .play-btn {
            background: linear-gradient(135deg, #6c5ce7, #a855f7);
            border: none;
            color: white;
            padding: 6px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .play-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(108, 92, 231, 0.4);
        }

        .play-btn.playing {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }

        .direction-btn {
            background: #3d3d5c;
            border: none;
            color: white;
            padding: 6px 12px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.2s, transform 0.2s;
        }

        .direction-btn:hover {
            background: #4d4d6c;
            transform: scale(1.05);
        }

        .direction-btn.counterclockwise {
            background: #2980b9;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: #888;
        }

        .speed-control input[type="range"] {
            width: 130px;
            accent-color: #6c5ce7;
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
            background: #3d3d5c;
            height: 6px;
            border-radius: 3px;
        }

        .speed-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #6c5ce7;
            border-radius: 50%;
            cursor: pointer;
        }

        .speed-control input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #6c5ce7;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        #speedValue {
            min-width: 32px;
            text-align: right;
        }

        /* Main Layout */
        .main-container {
            display: flex;
            height: calc(100vh - 70px);
        }

        /* Canvas Container */
        .canvas-container {
            flex: 1;
            position: relative;
            background: #16213e;
            overflow: hidden;
        }

        #gearCanvas {
            display: block;
            cursor: default;
        }

        /* Properties Panel */
        .panel {
            width: 260px;
            background: #1a1a2e;
            border-left: 1px solid #2d2d44;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .panel-section {
            padding: 15px;
            border-bottom: 1px solid #2d2d44;
        }

        .panel-title {
            font-size: 11px;
            text-transform: uppercase;
            color: #888;
            margin-bottom: 12px;
            letter-spacing: 1px;
        }

        /* Gear Palette */
        .gear-palette {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .palette-gear {
            background: #252538;
            border: 2px solid #3d3d5c;
            border-radius: 8px;
            padding: 12px 8px;
            text-align: center;
            cursor: grab;
            transition: all 0.2s;
        }

        .palette-gear:hover {
            border-color: #6c5ce7;
            background: #2d2d44;
            transform: translateY(-2px);
        }

        .palette-gear:active {
            cursor: grabbing;
        }

        .palette-gear-icon {
            font-size: 24px;
            margin-bottom: 4px;
        }

        .palette-gear-label {
            font-size: 11px;
            color: #aaa;
        }

        /* Selected Gear Properties */
        .property-row {
            margin-bottom: 12px;
        }

        .property-label {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 6px;
        }

        .property-row input[type="range"] {
            width: 100%;
            accent-color: #6c5ce7;
        }

        .property-row input[type="color"] {
            width: 100%;
            height: 32px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .property-value {
            font-size: 12px;
            color: #6c5ce7;
            font-weight: 500;
        }

        .property-btn {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 8px;
            transition: all 0.2s;
        }

        .btn-driver {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: white;
        }

        .btn-driver:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(243, 156, 18, 0.3);
        }

        .btn-driver.active {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
        }

        .btn-delete {
            background: #3d3d5c;
            color: #e74c3c;
        }

        .btn-delete:hover {
            background: #e74c3c;
            color: white;
        }

        /* Output Palette */
        .output-palette {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .palette-output {
            background: #252538;
            border: 2px solid #3d3d5c;
            border-radius: 8px;
            padding: 10px 12px;
            cursor: grab;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .palette-output:hover {
            border-color: #6c5ce7;
            background: #2d2d44;
        }

        .palette-output-icon {
            font-size: 20px;
        }

        .palette-output-label {
            font-size: 12px;
        }

        /* Status Bar */
        .status-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: #1a1a2e;
            border-top: 1px solid #2d2d44;
            padding: 6px 15px;
            height: 30px;
            font-size: 11px;
            color: #888;
        }

        .status-left, .status-right {
            display: flex;
            gap: 20px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .status-value {
            color: #6c5ce7;
            font-weight: 500;
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 50px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 13px;
            z-index: 10000;
            animation: slideIn 0.3s ease;
        }

        .toast.success {
            background: #27ae60;
            color: white;
        }

        .toast.error {
            background: #e74c3c;
            color: white;
        }

        .toast.info {
            background: #3498db;
            color: white;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* No Selection Helper */
        .no-selection {
            text-align: center;
            color: #666;
            font-size: 12px;
            padding: 20px;
        }

        /* Drag ghost */
        .drag-ghost {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            opacity: 0.8;
        }

        /* Settings Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.visible {
            display: flex;
        }

        .modal {
            background: #1a1a2e;
            border: 1px solid #3d3d5c;
            border-radius: 12px;
            width: 400px;
            max-width: 90%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .modal-header {
            padding: 15px 20px;
            border-bottom: 1px solid #2d2d44;
            font-size: 16px;
            font-weight: 600;
        }

        .modal-body {
            padding: 20px;
        }

        .modal-footer {
            padding: 15px 20px;
            border-top: 1px solid #2d2d44;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .modal-btn {
            padding: 8px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
        }

        .modal-btn-primary {
            background: linear-gradient(135deg, #6c5ce7, #a855f7);
            color: white;
        }

        .modal-btn-secondary {
            background: #3d3d5c;
            color: #ccc;
        }

        .setting-row {
            margin-bottom: 20px;
        }

        .setting-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 13px;
            color: #ccc;
        }

        .setting-value {
            color: #6c5ce7;
            font-weight: 600;
        }

        .setting-row input[type="range"] {
            width: 100%;
            accent-color: #6c5ce7;
        }

        .setting-description {
            font-size: 11px;
            color: #888;
            margin-top: 5px;
        }

        /* Help Icons */
        .help-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            background: #3d3d5c;
            border-radius: 50%;
            font-size: 11px;
            font-weight: bold;
            color: #aaa;
            cursor: pointer;
            margin-left: 8px;
            transition: all 0.2s;
            flex-shrink: 0;
        }

        .help-icon:hover {
            background: #6c5ce7;
            color: #fff;
            transform: scale(1.1);
        }

        .panel-title-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        /* Help Modal Styles */
        .help-modal {
            width: 500px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }

        .help-modal .modal-body {
            overflow-y: auto;
            max-height: 60vh;
        }

        .help-section {
            margin-bottom: 16px;
        }

        .help-section:last-child {
            margin-bottom: 0;
        }

        .help-section-title {
            font-size: 14px;
            font-weight: 600;
            color: #6c5ce7;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .help-section-title .icon {
            font-size: 16px;
        }

        .help-text {
            font-size: 13px;
            color: #ccc;
            line-height: 1.5;
            margin-bottom: 8px;
        }

        .help-tip {
            background: #2a2a3e;
            border-left: 3px solid #6c5ce7;
            padding: 10px 12px;
            font-size: 12px;
            color: #aaa;
            margin: 10px 0;
            border-radius: 0 6px 6px 0;
        }

        .help-tip strong {
            color: #fff;
        }

        .help-example {
            background: #16213e;
            border: 1px solid #3d3d5c;
            border-radius: 6px;
            padding: 12px;
            margin: 10px 0;
        }

        .help-example-title {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 6px;
        }

        .help-example-content {
            font-size: 13px;
            color: #fff;
        }

        .help-list {
            margin: 8px 0;
            padding-left: 20px;
        }

        .help-list li {
            font-size: 13px;
            color: #ccc;
            margin-bottom: 6px;
            line-height: 1.4;
        }

        .help-formula {
            font-family: monospace;
            background: #2a2a3e;
            padding: 2px 6px;
            border-radius: 4px;
            color: #a855f7;
        }
    </style>
</head>
<body>
    <!-- Menu Bar -->
    <div class="menu-bar">
        <div class="menu-left">
            <div class="menu-item">
                File
                <div class="dropdown">
                    <div class="dropdown-item" onclick="saveProject()">
                        Save <span class="shortcut">Ctrl+S</span>
                    </div>
                    <div class="divider"></div>
                    <div class="dropdown-item" onclick="exportImage()">Export as Image</div>
                </div>
            </div>
            <div class="menu-item">
                Edit
                <div class="dropdown">
                    <div class="dropdown-item" onclick="clearAll()">Clear All Gears</div>
                    <div class="dropdown-item" onclick="resetRotations()">Reset Rotations</div>
                </div>
            </div>
            <div class="menu-item">
                View
                <div class="dropdown">
                    <div class="dropdown-item" onclick="toggleGrid()">
                        <span id="gridToggleText">Hide Grid</span>
                    </div>
                    <div class="dropdown-item" onclick="resetZoom()">Reset Zoom</div>
                    <div class="divider"></div>
                    <div class="dropdown-item" onclick="showSettingsModal()">
                        Gear Settings...
                    </div>
                </div>
            </div>
        </div>

        <div class="playback-controls">
            <button class="play-btn" id="playBtn" onclick="togglePlay()">
                <span id="playIcon">&#9654;</span>
                <span id="playText">Play</span>
            </button>
            <button class="direction-btn" id="directionBtn" onclick="toggleDirection()" title="Toggle rotation direction">
                ↻
            </button>
            <div class="speed-control">
                <span>Speed:</span>
                <input type="range" id="speedSlider" min="0.2" max="10" step="0.2" value="1">
                <span id="speedValue">1x</span>
            </div>
            <span class="help-icon" onclick="showHelpModal('getting-started')" title="Getting Started" style="margin-left: 15px;">?</span>
        </div>
    </div>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Canvas -->
        <div class="canvas-container">
            <canvas id="gearCanvas"></canvas>
        </div>

        <!-- Properties Panel -->
        <div class="panel">
            <!-- Gear Palette -->
            <div class="panel-section">
                <div class="panel-title-row">
                    <div class="panel-title">Gear Palette</div>
                    <span class="help-icon" onclick="showHelpModal('gears')">?</span>
                </div>
                <div class="gear-palette">
                    <div class="palette-gear" draggable="true" data-teeth="8">
                        <div class="palette-gear-icon">&#9881;</div>
                        <div class="palette-gear-label">8 teeth</div>
                    </div>
                    <div class="palette-gear" draggable="true" data-teeth="12">
                        <div class="palette-gear-icon">&#9881;</div>
                        <div class="palette-gear-label">12 teeth</div>
                    </div>
                    <div class="palette-gear" draggable="true" data-teeth="16">
                        <div class="palette-gear-icon">&#9881;</div>
                        <div class="palette-gear-label">16 teeth</div>
                    </div>
                    <div class="palette-gear" draggable="true" data-teeth="24">
                        <div class="palette-gear-icon">&#9881;</div>
                        <div class="palette-gear-label">24 teeth</div>
                    </div>
                    <div class="palette-gear" draggable="true" data-teeth="32">
                        <div class="palette-gear-icon">&#9881;</div>
                        <div class="palette-gear-label">32 teeth</div>
                    </div>
                    <div class="palette-gear" draggable="true" data-teeth="48">
                        <div class="palette-gear-icon">&#9881;</div>
                        <div class="palette-gear-label">48 teeth</div>
                    </div>
                </div>
            </div>

            <!-- Selected Gear Properties -->
            <div class="panel-section" id="selectedGearPanel" style="display: none;">
                <div class="panel-title-row">
                    <div class="panel-title">Selected Gear</div>
                    <span class="help-icon" onclick="showHelpModal('properties')">?</span>
                </div>
                <div class="property-row">
                    <div class="property-label">Teeth Count: <span class="property-value" id="teethValue">12</span></div>
                    <input type="range" id="teethSlider" min="8" max="48" step="4" value="12">
                </div>
                <div class="property-row">
                    <div class="property-label">Color</div>
                    <input type="color" id="colorPicker" value="#6c5ce7">
                </div>
                <div class="property-row">
                    <div class="property-label">RPM: <span class="property-value" id="rpmValue">0</span></div>
                </div>

                <!-- Attached Image Section -->
                <div class="property-row" style="flex-direction: column; align-items: stretch;">
                    <div class="property-label" style="margin-bottom: 5px;">Attached Image</div>
                    <input type="text" id="imageUrlInput" placeholder="Paste image URL..."
                           style="width: 100%; padding: 6px; border: 1px solid #444; border-radius: 4px; background: #2a2a3e; color: #fff; font-size: 11px; box-sizing: border-box;">
                    <div id="imageControls" style="display: none; margin-top: 8px;">
                        <div style="display: flex; gap: 8px; margin-bottom: 6px;">
                            <div style="flex: 1;">
                                <label style="font-size: 10px; color: #888;">Offset X</label>
                                <input type="range" id="imageOffsetX" min="-100" max="100" value="0" style="width: 100%;">
                            </div>
                            <div style="flex: 1;">
                                <label style="font-size: 10px; color: #888;">Offset Y</label>
                                <input type="range" id="imageOffsetY" min="-100" max="100" value="0" style="width: 100%;">
                            </div>
                        </div>
                        <div>
                            <label style="font-size: 10px; color: #888;">Scale: <span id="imageScaleValue">1.0</span></label>
                            <input type="range" id="imageScale" min="0.1" max="3" step="0.1" value="1" style="width: 100%;">
                        </div>
                        <button class="property-btn" onclick="removeAttachedImage()" style="margin-top: 6px; background: #c0392b;">
                            Remove Image
                        </button>
                    </div>
                </div>

                <button class="property-btn btn-driver" id="driverBtn" onclick="toggleDriver()">
                    Make Driver Gear
                </button>
                <button class="property-btn btn-delete" onclick="deleteSelectedGear()">
                    Delete Gear
                </button>
            </div>

            <!-- No Selection Message -->
            <div class="panel-section" id="noSelectionPanel">
                <div class="no-selection">
                    Drag a gear from the palette above onto the canvas, or click an existing gear to select it.
                </div>
            </div>

            <!-- Output Palette -->
            <div class="panel-section">
                <div class="panel-title-row">
                    <div class="panel-title">Output Mechanisms</div>
                    <span class="help-icon" onclick="showHelpModal('outputs')">?</span>
                </div>
                <div class="output-palette">
                    <div class="palette-output" draggable="true" data-output="fan">
                        <span class="palette-output-icon">&#127744;</span>
                        <span class="palette-output-label">Fan Blade</span>
                    </div>
                    <div class="palette-output" draggable="true" data-output="clock">
                        <span class="palette-output-icon">&#128336;</span>
                        <span class="palette-output-label">Clock Hand</span>
                    </div>
                    <div class="palette-output" draggable="true" data-output="platform">
                        <span class="palette-output-icon">&#9898;</span>
                        <span class="palette-output-label">Platform</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar">
        <div class="status-left">
            <div class="status-item">
                Gears: <span class="status-value" id="gearCount">0</span>
            </div>
            <div class="status-item">
                Ratio: <span class="status-value" id="gearRatio">-</span>
            </div>
            <div class="status-item">
                Load: <span class="status-value" id="loadStatus" style="color: #2ecc71;">0%</span>
            </div>
        </div>
        <div class="status-right">
            <div class="status-item">
                Grid: <span class="status-value" id="gridStatus">ON</span>
            </div>
            <div class="status-item">
                Zoom: <span class="status-value" id="zoomLevel">100%</span>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal-overlay" id="settingsModal" onclick="hideSettingsModal(event)">
        <div class="modal" onclick="event.stopPropagation()">
            <div class="modal-header">Gear Settings</div>
            <div class="modal-body">
                <div class="setting-row">
                    <div class="setting-label">
                        <span>Tooth Thickness</span>
                        <span class="setting-value" id="thicknessValue">60%</span>
                    </div>
                    <input type="range" id="thicknessSlider" min="30" max="70" value="60"
                           oninput="updateThicknessSetting(this.value)">
                    <div class="setting-description">
                        Adjusts how thick the gear teeth are. Higher values = thicker teeth.
                    </div>
                </div>
                <div class="setting-row">
                    <div class="setting-label">
                        <span>Tooth Depth</span>
                        <span class="setting-value" id="depthValue">4px</span>
                    </div>
                    <input type="range" id="depthSlider" min="4" max="14" value="4"
                           oninput="updateDepthSetting(this.value)">
                    <div class="setting-description">
                        How far the teeth extend from the gear body.
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-secondary" onclick="hideSettingsModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Help Modal -->
    <div class="modal-overlay" id="helpModal" onclick="hideHelpModal(event)">
        <div class="modal help-modal" onclick="event.stopPropagation()">
            <div class="modal-header" id="helpModalTitle">Help</div>
            <div class="modal-body" id="helpModalContent">
                <!-- Content injected by JavaScript -->
            </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-secondary" onclick="hideHelpModal()">Close</button>
            </div>
        </div>
    </div>

    <script>
    // Help content for each section
    const helpContent = {
        'getting-started': {
            title: 'Getting Started with Gears',
            content: `
                <div class="help-section">
                    <div class="help-section-title"><span class="icon">&#9881;</span> Welcome to Gears!</div>
                    <div class="help-text">
                        Build and simulate mechanical gear systems! Watch how gears of different sizes interact,
                        learn about gear ratios, and see real physics in action.
                    </div>
                </div>

                <div class="help-section">
                    <div class="help-section-title"><span class="icon">&#128077;</span> Quick Start</div>
                    <ul class="help-list">
                        <li><strong>Add gears:</strong> Drag gears from the palette on the right onto the canvas</li>
                        <li><strong>Connect gears:</strong> Position gears close together - they'll automatically mesh</li>
                        <li><strong>Set a driver:</strong> Click a gear and press "Make Driver Gear" - this is the power source</li>
                        <li><strong>Start animation:</strong> Press the Play button or hit Spacebar</li>
                    </ul>
                </div>

                <div class="help-section">
                    <div class="help-section-title"><span class="icon">&#9000;</span> Keyboard Shortcuts</div>
                    <ul class="help-list">
                        <li><strong>Space:</strong> Play/Stop animation</li>
                        <li><strong>Delete:</strong> Remove selected gear or output</li>
                        <li><strong>Escape:</strong> Deselect all</li>
                        <li><strong>Ctrl+S:</strong> Save project</li>
                    </ul>
                </div>

                <div class="help-tip">
                    <strong>Tip:</strong> The gear with the orange ring is the driver gear - it powers all connected gears!
                </div>
            `
        },
        'gears': {
            title: 'Understanding Gears',
            content: `
                <div class="help-section">
                    <div class="help-section-title"><span class="icon">&#128218;</span> How to Add Gears</div>
                    <div class="help-text">
                        <strong>Drag and drop</strong> any gear from this palette onto the canvas workspace.
                        Each gear has a different number of teeth, which determines its size and behavior.
                    </div>
                </div>

                <div class="help-section">
                    <div class="help-section-title"><span class="icon">&#9881;</span> Gear Sizes & Teeth</div>
                    <div class="help-text">
                        The number of teeth on a gear determines two things:
                    </div>
                    <ul class="help-list">
                        <li><strong>Size:</strong> More teeth = bigger gear</li>
                        <li><strong>Speed:</strong> Smaller gears spin faster when driven by larger ones</li>
                    </ul>
                </div>

                <div class="help-section">
                    <div class="help-section-title"><span class="icon">&#128200;</span> Gear Ratios</div>
                    <div class="help-text">
                        When two gears mesh together, they create a <em>gear ratio</em>. This ratio determines
                        how fast the second gear spins compared to the first.
                    </div>
                    <div class="help-example">
                        <div class="help-example-title">Example</div>
                        <div class="help-example-content">
                            A 24-tooth gear driving a 12-tooth gear creates a <span class="help-formula">2:1 ratio</span><br>
                            The smaller gear spins <strong>twice as fast</strong> but with half the torque!
                        </div>
                    </div>
                </div>

                <div class="help-section">
                    <div class="help-section-title"><span class="icon">&#128260;</span> Direction of Rotation</div>
                    <div class="help-text">
                        Meshed gears always rotate in <strong>opposite directions</strong>. If the driver gear
                        spins clockwise, all directly connected gears spin counter-clockwise.
                    </div>
                </div>

                <div class="help-tip">
                    <strong>Real World:</strong> Bicycle gears use these same principles! Low gear (big front, small back)
                    is easier to pedal but slower. High gear is the opposite.
                </div>
            `
        },
        'properties': {
            title: 'Gear Properties',
            content: `
                <div class="help-section">
                    <div class="help-section-title"><span class="icon">&#9881;</span> Teeth Count</div>
                    <div class="help-text">
                        Adjust the number of teeth on the selected gear (8 to 48). This changes the gear's size
                        and affects its speed when connected to other gears.
                    </div>
                    <div class="help-tip">
                        <strong>Formula:</strong> <span class="help-formula">Output Speed = Input Speed × (Input Teeth ÷ Output Teeth)</span>
                    </div>
                </div>

                <div class="help-section">
                    <div class="help-section-title"><span class="icon">&#127912;</span> Color</div>
                    <div class="help-text">
                        Customize the color of your gear. Great for color-coding different parts of your gear train!
                    </div>
                </div>

                <div class="help-section">
                    <div class="help-section-title"><span class="icon">&#128336;</span> RPM (Rotations Per Minute)</div>
                    <div class="help-text">
                        Shows how fast this gear is spinning during animation. RPM changes based on:
                    </div>
                    <ul class="help-list">
                        <li>The speed slider setting</li>
                        <li>The gear ratio from the driver gear</li>
                        <li>System load (more gears = more resistance)</li>
                    </ul>
                </div>

                <div class="help-section">
                    <div class="help-section-title"><span class="icon">&#9733;</span> Driver Gear</div>
                    <div class="help-text">
                        The driver gear is the power source - like a motor. Only one gear can be the driver.
                        All other gears will follow based on their connections and ratios.
                    </div>
                </div>

                <div class="help-section">
                    <div class="help-section-title"><span class="icon">&#128444;</span> Attached Image</div>
                    <div class="help-text">
                        Attach an image from your assets that will rotate with the gear. Use offset and scale
                        controls to position it perfectly. Great for adding decorations or showing what the gear powers!
                    </div>
                </div>
            `
        },
        'outputs': {
            title: 'Output Mechanisms',
            content: `
                <div class="help-section">
                    <div class="help-section-title"><span class="icon">&#127744;</span> What Are Outputs?</div>
                    <div class="help-text">
                        Outputs are things that gears can power! Drag them onto a gear to attach them,
                        and they'll rotate along with that gear.
                    </div>
                </div>

                <div class="help-section">
                    <div class="help-section-title"><span class="icon">&#127744;</span> Fan Blade</div>
                    <div class="help-text">
                        A spinning fan with multiple blades. Attach it to a fast-spinning gear to see it whirl!
                    </div>
                </div>

                <div class="help-section">
                    <div class="help-section-title"><span class="icon">&#128336;</span> Clock Hand</div>
                    <div class="help-text">
                        A single pointer that rotates around the gear center. Perfect for showing rotation
                        speed or simulating a clock mechanism.
                    </div>
                </div>

                <div class="help-section">
                    <div class="help-section-title"><span class="icon">&#9898;</span> Platform</div>
                    <div class="help-text">
                        A circular platform that spins with the gear. Imagine it carrying objects around in a circle!
                    </div>
                </div>

                <div class="help-tip">
                    <strong>Try This:</strong> Create a gear train where a large driver gear powers a tiny gear,
                    then attach a fan to the tiny gear. Watch how fast it spins compared to the driver!
                </div>

                <div class="help-section">
                    <div class="help-section-title"><span class="icon">&#128161;</span> Real World Examples</div>
                    <ul class="help-list">
                        <li><strong>Ceiling fans</strong> use gear motors to spin at controlled speeds</li>
                        <li><strong>Clocks</strong> use precise gear ratios to move hands at exact speeds</li>
                        <li><strong>Conveyor belts</strong> are powered by gear-driven platforms</li>
                    </ul>
                </div>
            `
        }
    };
    </script>

    <script>
    // ============================================
    // Configuration and State
    // ============================================
    // Platform-managed - no APPLICATION_ID needed
    // Platform-managed - no PROJECT_ID needed
    // Platform-managed - no LOGIN_ID needed
    // Platform-managed - data comes via platform:load event

    let currentProjectId = null; // Platform-managed
    window.isDirty = false;

    // Application state
    const state = {
        gears: [],
        outputs: [],
        driverGearId: null,
        selectedGearId: null,
        selectedOutputId: null,
        settings: {
            gridSnap: true,
            gridSize: 20,
            autoSpinEnabled: false,
            spinSpeed: 1.0,
            spinDirection: 1, // 1 = clockwise, -1 = counterclockwise
            toothThickness: 0.60, // 0.3 to 0.7 (fraction of angular pitch)
            toothDepth: 4, // 4 to 14 pixels
            backgroundColor: '#1a1a2e'
        }
    };

    // Canvas state
    let canvas, ctx;
    let canvasWidth, canvasHeight;
    let zoom = 1;
    let panX = 0, panY = 0;

    // Gear system lock state (kinematic conflict detection)
    let systemLocked = false;
    let lockedGears = new Set(); // IDs of gears involved in lock conflict

    // Interaction state
    let isDragging = false;
    let isSpinning = false;
    let dragTarget = null;
    let dragOffsetX = 0, dragOffsetY = 0;
    let spinStartAngle = 0;
    let lastMouseX = 0, lastMouseY = 0;

    // Animation state
    let isPlaying = false;
    let lastTime = 0;
    let animationId = null;

    // Base rotation speed: 0.15 rotations/sec at 1x = 9 RPM base
    const BASE_ROTATION_SPEED = 0.15;

    // Drag from palette
    let paletteDropData = null;

    // Gear colors for variety
    const GEAR_COLORS = [
        '#6c5ce7', '#a855f7', '#3498db', '#1abc9c',
        '#e74c3c', '#f39c12', '#e91e63', '#00bcd4'
    ];

    // ============================================
    // Initialization
    // ============================================
    function init() {
        canvas = document.getElementById('gearCanvas');
        ctx = canvas.getContext('2d');

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Load initial data
        // loadProjectData called by platform:load event

        // Setup event listeners
        setupCanvasEvents();
        setupPaletteEvents();
        setupControlEvents();
        setupKeyboardShortcuts();

        // Start render loop
        requestAnimationFrame(gameLoop);

        // Setup auto-save
        // Auto-save handled by platform

        updateUI();
    }

    function resizeCanvas() {
        const container = canvas.parentElement;
        canvasWidth = container.clientWidth;
        canvasHeight = container.clientHeight;
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
    }

    function loadProjectData(data) {
        if (!data) return;

        if (data.settings) {
            Object.assign(state.settings, data.settings);
        }
        if (data.gears) {
            // Restore gears and recalculate derived properties
            state.gears = data.gears.map(g => ({
                ...g,
                radius: calculateRadius(g.teethCount),
                rotationSpeed: 0,
                meshingWith: [],
                phaseOffset: g.phaseOffset || 0,
                attachedImage: g.attachedImage || null
            }));

            // Reload attached images
            state.gears.forEach(gear => {
                if (gear.attachedImage && gear.attachedImage.url) {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = function() {
                        gear.attachedImage.imageObj = img;
                    };
                    img.src = gear.attachedImage.url;
                }
            });
        }
        if (data.outputs) {
            state.outputs = data.outputs;
        }
        if (data.driverGearId) {
            state.driverGearId = data.driverGearId;
        }

        // Update all gear connections and recalculate phase offsets
        updateAllConnections();

        // Sync UI controls with loaded settings
        syncSettingsUI();
    }

    // Sync UI controls with current settings (called after loading project)
    function syncSettingsUI() {
        // Speed slider
        const speedSlider = document.getElementById('speedSlider');
        const speedValue = document.getElementById('speedValue');
        if (speedSlider && speedValue) {
            speedSlider.value = state.settings.spinSpeed;
            const val = state.settings.spinSpeed;
            speedValue.textContent = (val % 1 ? val.toFixed(1) : val) + 'x';
        }

        // Settings modal sliders
        const thicknessSlider = document.getElementById('thicknessSlider');
        const thicknessValue = document.getElementById('thicknessValue');
        if (thicknessSlider && thicknessValue) {
            thicknessSlider.value = state.settings.toothThickness * 100;
            thicknessValue.textContent = Math.round(state.settings.toothThickness * 100) + '%';
        }

        const depthSlider = document.getElementById('depthSlider');
        const depthValue = document.getElementById('depthValue');
        if (depthSlider && depthValue) {
            depthSlider.value = state.settings.toothDepth;
            depthValue.textContent = state.settings.toothDepth + 'px';
        }
    }

    // ============================================
    // Gear Functions
    // ============================================
    function createGear(x, y, teethCount, color) {
        const gear = {
            id: 'gear_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
            x: x,
            y: y,
            teethCount: teethCount,
            radius: calculateRadius(teethCount),
            color: color || GEAR_COLORS[Math.floor(Math.random() * GEAR_COLORS.length)],
            rotation: 0,
            rotationSpeed: 0,
            meshingWith: [],
            // Phase offset relative to parent gear in the chain (for proper tooth interlocking)
            phaseOffset: 0,
            // Attached image (optional) - rotates with gear
            attachedImage: null // { url, offsetX, offsetY, scale, imageObj }
        };

        state.gears.push(gear);
        window.isDirty = true;
        updateAllConnections();
        return gear;
    }

    function calculateRadius(teethCount) {
        const moduleSize = 5;
        return teethCount * moduleSize / 2;
    }

    function deleteGear(gearId) {
        const index = state.gears.findIndex(g => g.id === gearId);
        if (index !== -1) {
            state.gears.splice(index, 1);

            // Remove any outputs attached to this gear
            state.outputs = state.outputs.filter(o => o.attachedToGear !== gearId);

            // Clear driver if this was the driver
            if (state.driverGearId === gearId) {
                state.driverGearId = null;
            }

            // Clear selection
            if (state.selectedGearId === gearId) {
                state.selectedGearId = null;
            }

            updateAllConnections();
            window.isDirty = true;
        }
    }

    function updateGearTeeth(gearId, newTeethCount) {
        const gear = state.gears.find(g => g.id === gearId);
        if (gear) {
            gear.teethCount = newTeethCount;
            gear.radius = calculateRadius(newTeethCount);
            updateAllConnections();
            window.isDirty = true;
        }
    }

    function updateGearColor(gearId, color) {
        const gear = state.gears.find(g => g.id === gearId);
        if (gear) {
            gear.color = color;
            window.isDirty = true;
        }
    }

    // Attached image functions
    function setAttachedImage(url) {
        if (!state.selectedGearId || !url) return;

        const gear = state.gears.find(g => g.id === state.selectedGearId);
        if (!gear) return;

        // Create image object and load it
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = function() {
            gear.attachedImage = {
                url: url,
                offsetX: 0,
                offsetY: 0,
                scale: 1,
                imageObj: img
            };
            window.isDirty = true;
            updateUI();
            showToast('Image attached!', 'success');
        };
        img.onerror = function() {
            showToast('Failed to load image', 'error');
        };
        img.src = url;
    }

    function updateAttachedImageProperty(property, value) {
        if (!state.selectedGearId) return;

        const gear = state.gears.find(g => g.id === state.selectedGearId);
        if (gear && gear.attachedImage) {
            gear.attachedImage[property] = value;
            window.isDirty = true;
        }
    }

    function removeAttachedImage() {
        if (!state.selectedGearId) return;

        const gear = state.gears.find(g => g.id === state.selectedGearId);
        if (gear) {
            gear.attachedImage = null;
            window.isDirty = true;
            updateUI();
            showToast('Image removed', 'info');
        }
    }

    function setDriverGear(gearId) {
        state.driverGearId = gearId;

        // Reset all rotation speeds
        state.gears.forEach(g => g.rotationSpeed = 0);

        // Set driver gear speed (use same formula as update() and propagateRotation())
        const driver = state.gears.find(g => g.id === gearId);
        if (driver) {
            driver.rotationSpeed = state.settings.spinSpeed * state.settings.spinDirection * BASE_ROTATION_SPEED;
            propagateRotation();
        }

        window.isDirty = true;
    }

    // ============================================
    // Gear Physics - Realistic Tooth Meshing
    // ============================================

    // Angular pitch: angle between adjacent teeth
    function getAngularPitch(gear) {
        return (2 * Math.PI) / gear.teethCount;
    }

    // Get the angle of tooth N (center of tooth tip)
    function getToothAngle(gear, toothIndex) {
        return toothIndex * getAngularPitch(gear) + gear.rotation;
    }

    // Get the angle of gap N (center of valley between teeth)
    function getGapAngle(gear, gapIndex) {
        return (gapIndex + 0.5) * getAngularPitch(gear) + gear.rotation;
    }

    // Normalize angle to [-PI, PI]
    function normalizeAngle(angle) {
        while (angle > Math.PI) angle -= 2 * Math.PI;
        while (angle < -Math.PI) angle += 2 * Math.PI;
        return angle;
    }

    function checkMeshing(gear1, gear2) {
        const dist = Math.hypot(gear2.x - gear1.x, gear2.y - gear1.y);
        const meshDist = gear1.radius + gear2.radius;
        const tolerance = 15;
        return Math.abs(dist - meshDist) < tolerance;
    }

    function canMesh(gear1, gear2) {
        const dist = Math.hypot(gear2.x - gear1.x, gear2.y - gear1.y);
        const meshDist = gear1.radius + gear2.radius;
        const snapTolerance = 30;
        return Math.abs(dist - meshDist) < snapTolerance;
    }

    function snapToMesh(movingGear, targetGear) {
        const angle = Math.atan2(movingGear.y - targetGear.y, movingGear.x - targetGear.x);
        const meshDist = movingGear.radius + targetGear.radius;

        movingGear.x = targetGear.x + Math.cos(angle) * meshDist;
        movingGear.y = targetGear.y + Math.sin(angle) * meshDist;

        // Calculate proper phase alignment so teeth interlock
        alignTeethForMeshing(movingGear, targetGear);
    }

    // Calculate the rotation offset needed for gear2's teeth to properly mesh with gear1
    function alignTeethForMeshing(gear2, gear1) {
        // Contact angle: direction from gear1 center to gear2 center
        const contactAngle = Math.atan2(gear2.y - gear1.y, gear2.x - gear1.x);

        // At the contact point, gear1 should have a tooth and gear2 should have a gap
        // Find the nearest tooth of gear1 to the contact angle
        const pitch1 = getAngularPitch(gear1);
        const tooth1Angle = gear1.rotation + Math.round((contactAngle - gear1.rotation) / pitch1) * pitch1;

        // The contact point from gear2's perspective is opposite
        const contactAngle2 = contactAngle + Math.PI;

        // Gear2 needs a gap at contactAngle2
        // Gap centers are at rotation + (i + 0.5) * pitch
        const pitch2 = getAngularPitch(gear2);

        // Calculate what rotation gear2 needs so that a gap aligns with contactAngle2
        // gap angle = rotation + (i + 0.5) * pitch = contactAngle2
        // We want to find the rotation that puts any gap at contactAngle2
        // rotation = contactAngle2 - (i + 0.5) * pitch
        // For i=0: rotation = contactAngle2 - 0.5 * pitch
        const targetRotation = contactAngle2 - 0.5 * pitch2;

        // Normalize to nearest valid position
        const currentGapOffset = normalizeAngle(gear2.rotation + 0.5 * pitch2 - contactAngle2);
        const adjustment = -currentGapOffset + Math.round(currentGapOffset / pitch2) * pitch2;

        gear2.rotation = normalizeAngle(gear2.rotation - currentGapOffset);
    }

    function updateAllConnections() {
        // Clear all connections
        state.gears.forEach(g => g.meshingWith = []);

        // Check all pairs
        for (let i = 0; i < state.gears.length; i++) {
            for (let j = i + 1; j < state.gears.length; j++) {
                if (checkMeshing(state.gears[i], state.gears[j])) {
                    state.gears[i].meshingWith.push(state.gears[j].id);
                    state.gears[j].meshingWith.push(state.gears[i].id);
                }
            }
        }

        // Calculate phase relationships and propagate rotation
        if (state.driverGearId) {
            calculatePhaseOffsets();
            propagateRotation();
        }

        updateUI();
    }

    // Calculate phase offsets for all gears relative to the driver
    // This establishes the tooth-gap alignment for proper meshing
    function calculatePhaseOffsets() {
        const driver = state.gears.find(g => g.id === state.driverGearId);
        if (!driver) return;

        // Driver has no phase offset
        driver.phaseOffset = 0;

        // BFS to calculate phase offsets through the gear train
        const visited = new Set([driver.id]);
        const queue = [driver];

        while (queue.length > 0) {
            const current = queue.shift();

            for (const connectedId of current.meshingWith) {
                if (!visited.has(connectedId)) {
                    const connected = state.gears.find(g => g.id === connectedId);
                    if (connected) {
                        // Calculate phase offset for proper meshing
                        connected.phaseOffset = calculateMeshPhaseOffset(current, connected);
                        visited.add(connectedId);
                        queue.push(connected);
                    }
                }
            }
        }
    }

    // Calculate the phase offset for gear2 to properly mesh with gear1
    // This ensures teeth interlock: gear1's tooth meets gear2's gap at contact point
    function calculateMeshPhaseOffset(gear1, gear2) {
        // Contact angle: direction from gear1 center to gear2 center
        const contactAngle = Math.atan2(gear2.y - gear1.y, gear2.x - gear1.x);

        // Angular pitch of each gear
        const pitch1 = getAngularPitch(gear1);
        const pitch2 = getAngularPitch(gear2);

        // Gear ratio
        const ratio = gear1.teethCount / gear2.teethCount;

        // For proper meshing:
        // - At the contact point, gear1 has a tooth pointing toward gear2
        // - Gear2 should have a gap (valley) at that same contact point
        //
        // Gear1's teeth are at angles: gear1.rotation + i * pitch1
        // Gear2's gaps (valleys) are at angles: gear2.rotation + (i + 0.5) * pitch2
        //
        // From gear2's perspective, the contact point is at angle (contactAngle + PI)
        // We need gear2's gap to be at this angle
        //
        // The phase offset accounts for:
        // 1. The contact angle from gear2's perspective
        // 2. The gear ratio relationship
        // 3. Half-pitch offset for gap alignment

        const contactAngle2 = contactAngle + Math.PI; // Contact from gear2's view

        // Phase offset so gear2's gap aligns with contact point
        // accounting for the inverse rotation relationship
        const offset = contactAngle2 - pitch2 / 2 + (contactAngle * ratio);

        return normalizeAngle(offset);
    }

    function propagateRotation() {
        // Reset lock state
        systemLocked = false;
        lockedGears.clear();

        // Reset all speeds except driver
        state.gears.forEach(g => {
            if (g.id !== state.driverGearId) {
                g.rotationSpeed = 0;
            }
        });

        const driver = state.gears.find(g => g.id === state.driverGearId);
        if (!driver) return;

        // Apply direction to spin speed with base speed multiplier
        driver.rotationSpeed = state.settings.spinSpeed * state.settings.spinDirection * BASE_ROTATION_SPEED;

        // BFS propagation with proper gear ratios AND conflict detection
        const visited = new Set([driver.id]);
        const gearSpeeds = new Map(); // Track expected speeds for conflict detection
        gearSpeeds.set(driver.id, driver.rotationSpeed);
        const queue = [driver];

        while (queue.length > 0) {
            const current = queue.shift();

            for (const connectedId of current.meshingWith) {
                const connected = state.gears.find(g => g.id === connectedId);
                if (!connected) continue;

                // Calculate what this gear's speed SHOULD be from this connection
                const ratio = current.teethCount / connected.teethCount;
                const expectedSpeed = -current.rotationSpeed * ratio;

                if (visited.has(connectedId)) {
                    // Already visited - check for kinematic conflict
                    const existingSpeed = gearSpeeds.get(connectedId);

                    // Allow small tolerance for floating point errors
                    const speedDiff = Math.abs(existingSpeed - expectedSpeed);
                    const tolerance = Math.abs(existingSpeed) * 0.01 + 0.0001;

                    if (speedDiff > tolerance) {
                        // CONFLICT DETECTED - gears would need to spin in incompatible ways
                        systemLocked = true;
                        lockedGears.add(current.id);
                        lockedGears.add(connectedId);
                    }
                } else {
                    // Not visited yet - set speed and continue propagation
                    connected.rotationSpeed = expectedSpeed;
                    gearSpeeds.set(connectedId, expectedSpeed);
                    visited.add(connectedId);
                    queue.push(connected);
                }
            }
        }

        // If system is locked, stop all rotation
        if (systemLocked) {
            state.gears.forEach(g => {
                g.rotationSpeed = 0;
            });
        }
    }

    // ============================================
    // Output Functions
    // ============================================
    function createOutput(type, x, y) {
        const output = {
            id: 'output_' + Date.now(),
            type: type,
            x: x,
            y: y,
            attachedToGear: null,
            rotation: 0,
            color: type === 'fan' ? '#3498db' : type === 'clock' ? '#2c3e50' : '#95a5a6'
        };

        // Try to attach to nearest gear
        let nearestGear = null;
        let nearestDist = Infinity;

        for (const gear of state.gears) {
            const dist = Math.hypot(x - gear.x, y - gear.y);
            if (dist < gear.radius + 30 && dist < nearestDist) {
                nearestDist = dist;
                nearestGear = gear;
            }
        }

        if (nearestGear) {
            output.attachedToGear = nearestGear.id;
            output.x = nearestGear.x;
            output.y = nearestGear.y;
        }

        state.outputs.push(output);
        window.isDirty = true;
        return output;
    }

    // ============================================
    // Rendering
    // ============================================
    function gameLoop(timestamp) {
        const deltaTime = (timestamp - lastTime) / 1000;
        lastTime = timestamp;

        if (isPlaying) {
            update(deltaTime);
        }

        render();
        animationId = requestAnimationFrame(gameLoop);
    }

    // Calculate system load based on connected gears
    // Returns a multiplier between 0 and 1 (1 = no load, lower = more load)
    function calculateSystemLoad() {
        // If system is locked due to kinematic conflict, return max load
        if (systemLocked) {
            return { multiplier: 0, percentage: 100, locked: true };
        }

        const driver = state.gears.find(g => g.id === state.driverGearId);
        if (!driver) return { multiplier: 1, percentage: 0, locked: false };

        // Find all gears connected to driver
        const connectedGears = [];
        const visited = new Set([driver.id]);
        const queue = [driver];

        while (queue.length > 0) {
            const current = queue.shift();
            connectedGears.push(current);

            for (const connectedId of current.meshingWith) {
                if (!visited.has(connectedId)) {
                    const connected = state.gears.find(g => g.id === connectedId);
                    if (connected) {
                        visited.add(connectedId);
                        queue.push(connected);
                    }
                }
            }
        }

        // Calculate total load from connected gears (excluding driver)
        // Load is based on gear radius (bigger gears = more resistance)
        let totalLoad = 0;
        for (const gear of connectedGears) {
            if (gear.id !== driver.id) {
                // Load contribution: larger gears add more load
                // Also factor in the gear ratio - gears spinning faster add more load
                totalLoad += gear.radius * 0.5;
            }
        }

        // Add load from outputs (they add extra resistance)
        state.outputs.forEach(output => {
            if (output.attachedToGear && visited.has(output.attachedToGear)) {
                totalLoad += 20; // Each output adds fixed load
            }
        });

        // Convert load to a speed multiplier
        // Formula: multiplier = driverPower / (driverPower + totalLoad)
        // This gives diminishing returns as load increases
        const driverPower = driver.radius * 2; // Driver's "power" based on its size
        const multiplier = driverPower / (driverPower + totalLoad);

        // Calculate load percentage for display (0% = no extra load, 100% = max load)
        const loadPercentage = Math.min(100, (totalLoad / driverPower) * 50);

        return { multiplier, percentage: loadPercentage, locked: false };
    }

    function update(deltaTime) {
        // Update driver gear rotation
        const driver = state.gears.find(g => g.id === state.driverGearId);
        if (driver) {
            // Calculate load from connected gears
            const { multiplier, percentage, locked } = calculateSystemLoad();

            // Update load display in status bar
            const loadDisplay = document.getElementById('loadStatus');
            if (loadDisplay) {
                if (locked) {
                    // System is locked - show LOCKED indicator
                    loadDisplay.textContent = 'LOCKED';
                    loadDisplay.style.color = '#ff0000';
                    loadDisplay.style.fontWeight = 'bold';
                    loadDisplay.style.animation = 'pulse 0.5s infinite';
                } else {
                    loadDisplay.textContent = percentage.toFixed(0) + '%';
                    loadDisplay.style.fontWeight = 'normal';
                    loadDisplay.style.animation = 'none';
                    // Color code: green (low) -> yellow -> red (high)
                    if (percentage < 30) {
                        loadDisplay.style.color = '#2ecc71';
                    } else if (percentage < 60) {
                        loadDisplay.style.color = '#f39c12';
                    } else {
                        loadDisplay.style.color = '#e74c3c';
                    }
                }
            }

            // Only rotate if not locked
            if (!locked) {
                // Apply load to speed - more gears = slower rotation
                const baseSpeed = state.settings.spinSpeed * state.settings.spinDirection * BASE_ROTATION_SPEED;
                const currentSpeed = baseSpeed * multiplier;

                driver.rotationSpeed = currentSpeed;
                driver.rotation += currentSpeed * deltaTime * Math.PI * 2;

                // Propagate rotation through gear train with proper synchronization
                synchronizeGearRotations(driver);
            }
        }

        // Update output rotations based on attached gear
        state.outputs.forEach(output => {
            if (output.attachedToGear) {
                const gear = state.gears.find(g => g.id === output.attachedToGear);
                if (gear) {
                    output.rotation = gear.rotation;
                    output.x = gear.x;
                    output.y = gear.y;
                }
            }
        });
    }

    // Synchronize all gear rotations based on driver rotation
    // This ensures teeth stay properly interlocked using gear ratios and phase offsets
    function synchronizeGearRotations(driver) {
        const visited = new Set([driver.id]);
        const queue = [{ gear: driver, speedMultiplier: 1 }];

        while (queue.length > 0) {
            const { gear: current, speedMultiplier } = queue.shift();

            for (const connectedId of current.meshingWith) {
                if (!visited.has(connectedId)) {
                    const connected = state.gears.find(g => g.id === connectedId);
                    if (connected) {
                        // Gear ratio: how much faster/slower connected spins relative to current
                        const ratio = current.teethCount / connected.teethCount;

                        // Calculate connected gear's rotation:
                        // - Opposite direction (negative)
                        // - Scaled by ratio
                        // - Plus phase offset to align teeth with gaps
                        connected.rotation = -(current.rotation * ratio) + connected.phaseOffset;

                        // Calculate rotation speed for RPM display
                        // Speed multiplier tracks cumulative ratio from driver
                        const newSpeedMultiplier = -speedMultiplier * ratio;
                        connected.rotationSpeed = driver.rotationSpeed * newSpeedMultiplier;

                        visited.add(connectedId);
                        queue.push({
                            gear: connected,
                            speedMultiplier: newSpeedMultiplier
                        });
                    }
                }
            }
        }
    }

    function render() {
        // Clear canvas
        ctx.fillStyle = state.settings.backgroundColor;
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);

        ctx.save();
        ctx.translate(panX, panY);
        ctx.scale(zoom, zoom);

        // Draw grid
        if (state.settings.gridSnap) {
            drawGrid();
        }

        // Draw meshing highlights
        drawMeshingHighlights();

        // Draw gears
        state.gears.forEach(gear => {
            drawGear(gear);
        });

        // Draw outputs
        state.outputs.forEach(output => {
            drawOutput(output);
        });

        // Draw potential snap indicator when dragging
        if (isDragging && dragTarget && dragTarget.type === 'gear') {
            drawSnapIndicators(dragTarget.item);
        }

        ctx.restore();
    }

    function drawGrid() {
        const gridSize = state.settings.gridSize;
        ctx.strokeStyle = '#2d2d44';
        ctx.lineWidth = 0.5;

        const startX = Math.floor(-panX / zoom / gridSize) * gridSize;
        const startY = Math.floor(-panY / zoom / gridSize) * gridSize;
        const endX = startX + canvasWidth / zoom + gridSize;
        const endY = startY + canvasHeight / zoom + gridSize;

        ctx.beginPath();
        for (let x = startX; x <= endX; x += gridSize) {
            ctx.moveTo(x, startY);
            ctx.lineTo(x, endY);
        }
        for (let y = startY; y <= endY; y += gridSize) {
            ctx.moveTo(startX, y);
            ctx.lineTo(endX, y);
        }
        ctx.stroke();
    }

    function drawGear(gear) {
        const toothDepth = state.settings.toothDepth;
        const toothWidthFactor = state.settings.toothThickness; // Width of tooth base as fraction of angular pitch
        const taperRatio = 0.65; // Tip width as fraction of base width (smaller = more taper)

        ctx.save();
        ctx.translate(gear.x, gear.y);
        ctx.rotate(gear.rotation);

        // Draw selection ring
        if (gear.id === state.selectedGearId) {
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, gear.radius + toothDepth + 5, 0, Math.PI * 2);
            ctx.stroke();
        }

        // Draw driver indicator
        if (gear.id === state.driverGearId) {
            ctx.strokeStyle = '#f39c12';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(0, 0, gear.radius + toothDepth + 10, 0, Math.PI * 2);
            ctx.stroke();
        }

        // Draw locked gear indicator (red pulsing glow)
        if (lockedGears.has(gear.id)) {
            const pulseIntensity = 0.5 + 0.5 * Math.sin(Date.now() / 200);
            ctx.save();
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 20 + pulseIntensity * 10;
            ctx.strokeStyle = `rgba(255, 0, 0, ${0.6 + pulseIntensity * 0.4})`;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(0, 0, gear.radius + toothDepth + 8, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }

        // Draw gear body with tapered teeth (narrower at tip, wider at base)
        // For realistic meshing: dedendum (valley) must be deeper than addendum (tooth height)
        const angularPitch = (Math.PI * 2) / gear.teethCount;
        const outerRadius = gear.radius + toothDepth;  // Addendum (tooth tip)
        const innerRadius = gear.radius - toothDepth * 1.2;  // Dedendum (valley) - deeper for clearance
        const baseHalfWidth = angularPitch * toothWidthFactor / 2;
        const tipHalfWidth = baseHalfWidth * taperRatio;

        ctx.beginPath();

        for (let i = 0; i < gear.teethCount; i++) {
            const toothCenter = i * angularPitch;

            // Tooth tip (narrower) - at outer radius
            const tipStart = toothCenter - tipHalfWidth;
            const tipEnd = toothCenter + tipHalfWidth;

            // Tooth base (wider) - at inner radius
            const baseStart = toothCenter - baseHalfWidth;
            const baseEnd = toothCenter + baseHalfWidth;

            // Valley angles
            const valleyEnd = toothCenter + angularPitch - baseHalfWidth;
            const nextTipStart = toothCenter + angularPitch - tipHalfWidth;

            if (i === 0) {
                // Start at tip of first tooth
                ctx.moveTo(
                    Math.cos(tipStart) * outerRadius,
                    Math.sin(tipStart) * outerRadius
                );
            }

            // Top of tooth (narrow tip)
            ctx.lineTo(
                Math.cos(tipEnd) * outerRadius,
                Math.sin(tipEnd) * outerRadius
            );

            // Angled line down to base (creates taper)
            ctx.lineTo(
                Math.cos(baseEnd) * innerRadius,
                Math.sin(baseEnd) * innerRadius
            );

            // Valley floor
            ctx.lineTo(
                Math.cos(valleyEnd) * innerRadius,
                Math.sin(valleyEnd) * innerRadius
            );

            // Angled line up to next tooth tip (creates taper)
            ctx.lineTo(
                Math.cos(nextTipStart) * outerRadius,
                Math.sin(nextTipStart) * outerRadius
            );
        }

        ctx.closePath();

        // Fill gear body
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, gear.radius);
        gradient.addColorStop(0, lightenColor(gear.color, 30));
        gradient.addColorStop(1, gear.color);
        ctx.fillStyle = gradient;
        ctx.fill();

        // Stroke outline
        ctx.strokeStyle = darkenColor(gear.color, 30);
        ctx.lineWidth = 2;
        ctx.stroke();

        // Draw center hole
        ctx.beginPath();
        ctx.arc(0, 0, 8, 0, Math.PI * 2);
        ctx.fillStyle = '#1a1a2e';
        ctx.fill();
        ctx.strokeStyle = darkenColor(gear.color, 40);
        ctx.lineWidth = 2;
        ctx.stroke();

        // Draw center axle
        ctx.beginPath();
        ctx.arc(0, 0, 4, 0, Math.PI * 2);
        ctx.fillStyle = '#555';
        ctx.fill();

        // Draw attached image (rotates with gear)
        if (gear.attachedImage && gear.attachedImage.imageObj) {
            const img = gear.attachedImage.imageObj;
            const scale = gear.attachedImage.scale || 1;
            const offsetX = gear.attachedImage.offsetX || 0;
            const offsetY = gear.attachedImage.offsetY || 0;

            // Calculate scaled dimensions
            const maxSize = gear.radius * 1.5;
            const aspectRatio = img.width / img.height;
            let drawWidth, drawHeight;

            if (aspectRatio > 1) {
                drawWidth = maxSize * scale;
                drawHeight = drawWidth / aspectRatio;
            } else {
                drawHeight = maxSize * scale;
                drawWidth = drawHeight * aspectRatio;
            }

            // Draw image centered with offset
            ctx.drawImage(
                img,
                offsetX - drawWidth / 2,
                offsetY - drawHeight / 2,
                drawWidth,
                drawHeight
            );
        }

        ctx.restore();

        // Draw RPM display when spinning (outside of rotation transform)
        if (isPlaying && gear.rotationSpeed !== 0) {
            const rpm = Math.abs(gear.rotationSpeed * 60).toFixed(0);
            const direction = gear.rotationSpeed > 0 ? '↻' : '↺';

            ctx.save();
            ctx.translate(gear.x, gear.y);

            // Background pill for RPM
            const text = direction + ' ' + rpm;
            ctx.font = 'bold 11px sans-serif';
            const textWidth = ctx.measureText(text).width;
            const pillWidth = textWidth + 12;
            const pillHeight = 18;
            const pillY = -gear.radius - toothDepth - 18;

            // Draw pill background
            ctx.beginPath();
            ctx.roundRect(-pillWidth/2, pillY - pillHeight/2, pillWidth, pillHeight, 9);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fill();

            // Draw text
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 0, pillY);

            // Draw "RPM" label below
            ctx.font = '9px sans-serif';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.fillText('RPM', 0, pillY + 12);

            ctx.restore();
        }
    }

    function drawMeshingHighlights() {
        // Draw connection lines between meshed gears
        ctx.strokeStyle = 'rgba(108, 92, 231, 0.3)';
        ctx.lineWidth = 3;

        const drawnPairs = new Set();

        state.gears.forEach(gear => {
            gear.meshingWith.forEach(otherId => {
                const pairKey = [gear.id, otherId].sort().join('-');
                if (!drawnPairs.has(pairKey)) {
                    drawnPairs.add(pairKey);
                    const other = state.gears.find(g => g.id === otherId);
                    if (other) {
                        // Draw glow at connection point
                        const midX = (gear.x + other.x) / 2;
                        const midY = (gear.y + other.y) / 2;

                        const gradient = ctx.createRadialGradient(midX, midY, 0, midX, midY, 20);
                        gradient.addColorStop(0, 'rgba(108, 92, 231, 0.5)');
                        gradient.addColorStop(1, 'rgba(108, 92, 231, 0)');

                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(midX, midY, 20, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            });
        });
    }

    function drawSnapIndicators(gear) {
        // Show potential snap positions
        state.gears.forEach(other => {
            if (other.id !== gear.id && canMesh(gear, other) && !checkMeshing(gear, other)) {
                // Draw green indicator showing snap position
                const angle = Math.atan2(gear.y - other.y, gear.x - other.x);
                const meshDist = gear.radius + other.radius;
                const snapX = other.x + Math.cos(angle) * meshDist;
                const snapY = other.y + Math.sin(angle) * meshDist;

                ctx.strokeStyle = '#27ae60';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(snapX, snapY, gear.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        });
    }

    function drawOutput(output) {
        ctx.save();
        ctx.translate(output.x, output.y);

        // Draw selection indicator (before rotation so it stays circular)
        if (output.id === state.selectedOutputId) {
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            let selectionRadius = 50;
            if (output.type === 'fan') selectionRadius = 60;
            else if (output.type === 'clock') selectionRadius = 50;
            else if (output.type === 'platform') selectionRadius = 45;
            ctx.arc(0, 0, selectionRadius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        ctx.rotate(output.rotation);

        switch (output.type) {
            case 'fan':
                drawFan(output);
                break;
            case 'clock':
                drawClock(output);
                break;
            case 'platform':
                drawPlatform(output);
                break;
        }

        ctx.restore();
    }

    function drawFan(output) {
        const bladeCount = 4;
        const bladeLength = 50;
        const bladeWidth = 15;

        ctx.fillStyle = output.color;

        for (let i = 0; i < bladeCount; i++) {
            ctx.save();
            ctx.rotate((i / bladeCount) * Math.PI * 2);

            ctx.beginPath();
            ctx.ellipse(bladeLength / 2, 0, bladeLength / 2, bladeWidth / 2, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // Center hub
        ctx.beginPath();
        ctx.arc(0, 0, 10, 0, Math.PI * 2);
        ctx.fillStyle = '#34495e';
        ctx.fill();
    }

    function drawClock(output) {
        // Clock face
        ctx.beginPath();
        ctx.arc(0, 0, 40, 0, Math.PI * 2);
        ctx.fillStyle = '#ecf0f1';
        ctx.fill();
        ctx.strokeStyle = '#2c3e50';
        ctx.lineWidth = 3;
        ctx.stroke();

        // Hour markers
        for (let i = 0; i < 12; i++) {
            const angle = (i / 12) * Math.PI * 2 - Math.PI / 2;
            const x1 = Math.cos(angle) * 32;
            const y1 = Math.sin(angle) * 32;
            const x2 = Math.cos(angle) * 38;
            const y2 = Math.sin(angle) * 38;

            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // Clock hand (rotates with gear)
        ctx.beginPath();
        ctx.moveTo(0, 5);
        ctx.lineTo(0, -30);
        ctx.strokeStyle = '#e74c3c';
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.stroke();

        // Center dot
        ctx.beginPath();
        ctx.arc(0, 0, 4, 0, Math.PI * 2);
        ctx.fillStyle = '#e74c3c';
        ctx.fill();
    }

    function drawPlatform(output) {
        // Platform base
        ctx.beginPath();
        ctx.arc(0, 0, 35, 0, Math.PI * 2);
        ctx.fillStyle = '#7f8c8d';
        ctx.fill();
        ctx.strokeStyle = '#5d6d7e';
        ctx.lineWidth = 3;
        ctx.stroke();

        // Rotation indicator lines
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            ctx.beginPath();
            ctx.moveTo(Math.cos(angle) * 10, Math.sin(angle) * 10);
            ctx.lineTo(Math.cos(angle) * 30, Math.sin(angle) * 30);
            ctx.strokeStyle = '#5d6d7e';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // Center marker
        ctx.beginPath();
        ctx.arc(0, 0, 8, 0, Math.PI * 2);
        ctx.fillStyle = '#34495e';
        ctx.fill();
    }

    // ============================================
    // Color Utilities
    // ============================================
    function lightenColor(color, percent) {
        const num = parseInt(color.replace('#', ''), 16);
        const amt = Math.round(2.55 * percent);
        const R = Math.min(255, (num >> 16) + amt);
        const G = Math.min(255, ((num >> 8) & 0x00FF) + amt);
        const B = Math.min(255, (num & 0x0000FF) + amt);
        return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
    }

    function darkenColor(color, percent) {
        const num = parseInt(color.replace('#', ''), 16);
        const amt = Math.round(2.55 * percent);
        const R = Math.max(0, (num >> 16) - amt);
        const G = Math.max(0, ((num >> 8) & 0x00FF) - amt);
        const B = Math.max(0, (num & 0x0000FF) - amt);
        return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
    }

    // ============================================
    // Event Handlers
    // ============================================
    function setupCanvasEvents() {
        canvas.addEventListener('mousedown', onMouseDown);
        canvas.addEventListener('mousemove', onMouseMove);
        canvas.addEventListener('mouseup', onMouseUp);
        canvas.addEventListener('mouseleave', onMouseUp);
        canvas.addEventListener('wheel', onWheel);

        // Prevent context menu
        canvas.addEventListener('contextmenu', e => e.preventDefault());

        // Drop zone for palette items
        canvas.addEventListener('dragover', e => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        });

        canvas.addEventListener('drop', onCanvasDrop);
    }

    function setupPaletteEvents() {
        // Gear palette
        document.querySelectorAll('.palette-gear').forEach(el => {
            el.addEventListener('dragstart', e => {
                const teeth = parseInt(el.dataset.teeth);
                e.dataTransfer.setData('text/plain', JSON.stringify({ type: 'gear', teeth: teeth }));
                e.dataTransfer.effectAllowed = 'copy';
            });
        });

        // Output palette
        document.querySelectorAll('.palette-output').forEach(el => {
            el.addEventListener('dragstart', e => {
                const outputType = el.dataset.output;
                e.dataTransfer.setData('text/plain', JSON.stringify({ type: 'output', outputType: outputType }));
                e.dataTransfer.effectAllowed = 'copy';
            });
        });
    }

    function setupControlEvents() {
        // Speed slider - minimal work during drag
        const speedSlider = document.getElementById('speedSlider');
        const speedValue = document.getElementById('speedValue');

        speedSlider.addEventListener('input', e => {
            const val = +e.target.value;
            state.settings.spinSpeed = val;
            speedValue.textContent = (val % 1 ? val.toFixed(1) : val) + 'x';
        });

        speedSlider.addEventListener('change', () => {
            window.isDirty = true;
        });

        // Teeth slider
        document.getElementById('teethSlider').addEventListener('input', e => {
            const teeth = parseInt(e.target.value);
            document.getElementById('teethValue').textContent = teeth;
            if (state.selectedGearId) {
                updateGearTeeth(state.selectedGearId, teeth);
            }
        });

        // Color picker
        document.getElementById('colorPicker').addEventListener('input', e => {
            if (state.selectedGearId) {
                updateGearColor(state.selectedGearId, e.target.value);
            }
        });

        // Image URL input - load image on Enter or blur
        const imageUrlInput = document.getElementById('imageUrlInput');
        imageUrlInput.addEventListener('keydown', e => {
            if (e.key === 'Enter') {
                e.preventDefault();
                setAttachedImage(imageUrlInput.value.trim());
            }
        });
        imageUrlInput.addEventListener('blur', () => {
            const url = imageUrlInput.value.trim();
            if (url && state.selectedGearId) {
                const gear = state.gears.find(g => g.id === state.selectedGearId);
                if (gear && (!gear.attachedImage || gear.attachedImage.url !== url)) {
                    setAttachedImage(url);
                }
            }
        });

        // Image offset and scale sliders
        document.getElementById('imageOffsetX').addEventListener('input', e => {
            updateAttachedImageProperty('offsetX', parseInt(e.target.value));
        });
        document.getElementById('imageOffsetY').addEventListener('input', e => {
            updateAttachedImageProperty('offsetY', parseInt(e.target.value));
        });
        document.getElementById('imageScale').addEventListener('input', e => {
            const scale = parseFloat(e.target.value);
            document.getElementById('imageScaleValue').textContent = scale.toFixed(1);
            updateAttachedImageProperty('scale', scale);
        });
    }

    function setupKeyboardShortcuts() {
        document.addEventListener('keydown', e => {
            // Ctrl+S to save
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                saveProject();
            }

            // Delete key to delete selected gear or output
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (document.activeElement === document.body) {
                    if (state.selectedGearId) {
                        e.preventDefault();
                        deleteSelectedGear();
                    } else if (state.selectedOutputId) {
                        e.preventDefault();
                        deleteSelectedOutput();
                    }
                }
            }

            // Space to toggle play
            if (e.key === ' ' && document.activeElement === document.body) {
                e.preventDefault();
                togglePlay();
            }

            // Escape to deselect
            if (e.key === 'Escape') {
                state.selectedGearId = null;
                state.selectedOutputId = null;
                updateUI();
            }
        });
    }

    function onMouseDown(e) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = (e.clientX - rect.left - panX) / zoom;
        const mouseY = (e.clientY - rect.top - panY) / zoom;

        lastMouseX = e.clientX;
        lastMouseY = e.clientY;

        // Check for output hit first (they render on top)
        const hitOutput = hitTestOutput(mouseX, mouseY);
        // Check for gear hit
        const hitGear = hitTestGear(mouseX, mouseY);

        if (e.button === 0) { // Left click
            if (hitOutput) {
                // Clicked on an output - select and start dragging
                state.selectedOutputId = hitOutput.id;
                state.selectedGearId = null;
                updateUI();

                isDragging = true;
                dragTarget = { type: 'output', item: hitOutput };
                dragOffsetX = mouseX - hitOutput.x;
                dragOffsetY = mouseY - hitOutput.y;
                canvas.style.cursor = 'grabbing';
            } else if (hitGear) {
                state.selectedGearId = hitGear.id;
                state.selectedOutputId = null;
                updateUI();

                // Check if clicking on driver gear for manual spin
                if (hitGear.id === state.driverGearId && !isPlaying) {
                    isSpinning = true;
                    spinStartAngle = Math.atan2(mouseY - hitGear.y, mouseX - hitGear.x);
                    canvas.style.cursor = 'grabbing';
                } else {
                    // Start dragging
                    isDragging = true;
                    dragTarget = { type: 'gear', item: hitGear };
                    dragOffsetX = mouseX - hitGear.x;
                    dragOffsetY = mouseY - hitGear.y;
                    canvas.style.cursor = 'grabbing';
                }
            } else {
                state.selectedGearId = null;
                state.selectedOutputId = null;
                updateUI();
            }
        } else if (e.button === 1) { // Middle click - pan
            isDragging = true;
            dragTarget = { type: 'pan' };
            canvas.style.cursor = 'move';
        }
    }

    function onMouseMove(e) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = (e.clientX - rect.left - panX) / zoom;
        const mouseY = (e.clientY - rect.top - panY) / zoom;

        if (isSpinning && state.driverGearId) {
            const driver = state.gears.find(g => g.id === state.driverGearId);
            if (driver) {
                const currentAngle = Math.atan2(mouseY - driver.y, mouseX - driver.x);
                let deltaAngle = currentAngle - spinStartAngle;

                // Apply rotation
                driver.rotation += deltaAngle;
                spinStartAngle = currentAngle;

                // Propagate to connected gears (manual mode)
                propagateManualRotation(driver);
            }
        } else if (isDragging && dragTarget) {
            if (dragTarget.type === 'gear') {
                let newX = mouseX - dragOffsetX;
                let newY = mouseY - dragOffsetY;

                // Grid snap
                if (state.settings.gridSnap) {
                    newX = Math.round(newX / state.settings.gridSize) * state.settings.gridSize;
                    newY = Math.round(newY / state.settings.gridSize) * state.settings.gridSize;
                }

                dragTarget.item.x = newX;
                dragTarget.item.y = newY;

                // Check for snap-to-mesh
                for (const other of state.gears) {
                    if (other.id !== dragTarget.item.id && canMesh(dragTarget.item, other)) {
                        snapToMesh(dragTarget.item, other);
                        break;
                    }
                }
            } else if (dragTarget.type === 'output') {
                // Drag output - temporarily detach from gear
                let newX = mouseX - dragOffsetX;
                let newY = mouseY - dragOffsetY;

                // Grid snap for outputs too
                if (state.settings.gridSnap) {
                    newX = Math.round(newX / state.settings.gridSize) * state.settings.gridSize;
                    newY = Math.round(newY / state.settings.gridSize) * state.settings.gridSize;
                }

                dragTarget.item.x = newX;
                dragTarget.item.y = newY;
                dragTarget.item.attachedToGear = null; // Detach while dragging
            } else if (dragTarget.type === 'pan') {
                panX += e.clientX - lastMouseX;
                panY += e.clientY - lastMouseY;
            }
        } else {
            // Update cursor based on what's under mouse
            const hitOutput = hitTestOutput(mouseX, mouseY);
            const hitGear = hitTestGear(mouseX, mouseY);
            if (hitOutput) {
                canvas.style.cursor = 'move';
            } else if (hitGear) {
                canvas.style.cursor = hitGear.id === state.driverGearId ? 'grab' : 'move';
            } else {
                canvas.style.cursor = 'default';
            }
        }

        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
    }

    function onMouseUp(e) {
        if (isDragging && dragTarget) {
            if (dragTarget.type === 'gear') {
                updateAllConnections();
                window.isDirty = true;
            } else if (dragTarget.type === 'output') {
                // Try to attach output to nearest gear
                const output = dragTarget.item;
                let nearestGear = null;
                let nearestDist = Infinity;

                for (const gear of state.gears) {
                    const dist = Math.hypot(output.x - gear.x, output.y - gear.y);
                    if (dist < gear.radius + 30 && dist < nearestDist) {
                        nearestDist = dist;
                        nearestGear = gear;
                    }
                }

                if (nearestGear) {
                    output.attachedToGear = nearestGear.id;
                    output.x = nearestGear.x;
                    output.y = nearestGear.y;
                    output.rotation = nearestGear.rotation;
                    showToast('Output attached to gear', 'success');
                } else {
                    showToast('Drop on a gear to attach', 'info');
                }
                window.isDirty = true;
            }
        }

        isDragging = false;
        isSpinning = false;
        dragTarget = null;
        canvas.style.cursor = 'default';
    }

    function onWheel(e) {
        e.preventDefault();

        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
        const newZoom = Math.max(0.25, Math.min(4, zoom * zoomFactor));

        // Zoom toward mouse position
        panX = mouseX - (mouseX - panX) * (newZoom / zoom);
        panY = mouseY - (mouseY - panY) * (newZoom / zoom);
        zoom = newZoom;

        document.getElementById('zoomLevel').textContent = Math.round(zoom * 100) + '%';
    }

    function onCanvasDrop(e) {
        e.preventDefault();

        try {
            const data = JSON.parse(e.dataTransfer.getData('text/plain'));
            const rect = canvas.getBoundingClientRect();
            let x = (e.clientX - rect.left - panX) / zoom;
            let y = (e.clientY - rect.top - panY) / zoom;

            // Grid snap
            if (state.settings.gridSnap) {
                x = Math.round(x / state.settings.gridSize) * state.settings.gridSize;
                y = Math.round(y / state.settings.gridSize) * state.settings.gridSize;
            }

            if (data.type === 'gear') {
                const gear = createGear(x, y, data.teeth);
                state.selectedGearId = gear.id;
                showToast('Gear added! Drag near another gear to connect.', 'info');
            } else if (data.type === 'output') {
                const output = createOutput(data.outputType, x, y);
                if (!output.attachedToGear) {
                    showToast('Drop output on a gear to attach it.', 'info');
                } else {
                    showToast('Output attached to gear!', 'success');
                }
            }

            updateUI();
        } catch (err) {
            console.error('Drop error:', err);
        }
    }

    function hitTestGear(x, y) {
        // Check in reverse order (top-most first)
        for (let i = state.gears.length - 1; i >= 0; i--) {
            const gear = state.gears[i];
            const dist = Math.hypot(x - gear.x, y - gear.y);
            if (dist <= gear.radius + 8) {
                return gear;
            }
        }
        return null;
    }

    function hitTestOutput(x, y) {
        // Check outputs - they have different hit areas based on type
        for (let i = state.outputs.length - 1; i >= 0; i--) {
            const output = state.outputs[i];
            const dist = Math.hypot(x - output.x, y - output.y);
            let hitRadius = 40; // Default hit radius

            switch (output.type) {
                case 'fan':
                    hitRadius = 55; // Fan blades extend further
                    break;
                case 'clock':
                    hitRadius = 45;
                    break;
                case 'platform':
                    hitRadius = 40;
                    break;
            }

            if (dist <= hitRadius) {
                return output;
            }
        }
        return null;
    }

    function propagateManualRotation(driver) {
        // Use the same synchronized rotation logic as auto-play
        synchronizeGearRotations(driver);

        // Update outputs
        state.outputs.forEach(output => {
            if (output.attachedToGear) {
                const gear = state.gears.find(g => g.id === output.attachedToGear);
                if (gear) {
                    output.rotation = gear.rotation;
                }
            }
        });
    }

    // ============================================
    // UI Functions
    // ============================================
    function updateUI() {
        // Update gear count
        document.getElementById('gearCount').textContent = state.gears.length;

        // Update selected gear panel
        const selectedPanel = document.getElementById('selectedGearPanel');
        const noSelectionPanel = document.getElementById('noSelectionPanel');

        if (state.selectedGearId) {
            const gear = state.gears.find(g => g.id === state.selectedGearId);
            if (gear) {
                selectedPanel.style.display = 'block';
                noSelectionPanel.style.display = 'none';

                document.getElementById('teethSlider').value = gear.teethCount;
                document.getElementById('teethValue').textContent = gear.teethCount;
                document.getElementById('colorPicker').value = gear.color;

                // Calculate and display RPM
                const rpm = Math.abs(gear.rotationSpeed * 60).toFixed(1);
                document.getElementById('rpmValue').textContent = rpm;

                // Update driver button
                const driverBtn = document.getElementById('driverBtn');
                if (gear.id === state.driverGearId) {
                    driverBtn.textContent = 'Driver Gear';
                    driverBtn.classList.add('active');
                } else {
                    driverBtn.textContent = 'Make Driver Gear';
                    driverBtn.classList.remove('active');
                }

                // Update gear ratio
                if (state.driverGearId && gear.id !== state.driverGearId) {
                    const driver = state.gears.find(g => g.id === state.driverGearId);
                    if (driver) {
                        const ratio = (driver.teethCount / gear.teethCount).toFixed(2);
                        document.getElementById('gearRatio').textContent = '1:' + ratio;
                    }
                } else {
                    document.getElementById('gearRatio').textContent = '-';
                }

                // Update attached image controls
                const imageControls = document.getElementById('imageControls');
                const imageUrlInput = document.getElementById('imageUrlInput');
                if (gear.attachedImage) {
                    imageUrlInput.value = gear.attachedImage.url || '';
                    imageControls.style.display = 'block';
                    document.getElementById('imageOffsetX').value = gear.attachedImage.offsetX || 0;
                    document.getElementById('imageOffsetY').value = gear.attachedImage.offsetY || 0;
                    document.getElementById('imageScale').value = gear.attachedImage.scale || 1;
                    document.getElementById('imageScaleValue').textContent = (gear.attachedImage.scale || 1).toFixed(1);
                } else {
                    imageUrlInput.value = '';
                    imageControls.style.display = 'none';
                }
            }
        } else {
            selectedPanel.style.display = 'none';
            noSelectionPanel.style.display = 'block';
            document.getElementById('gearRatio').textContent = '-';
        }

        // Update grid status
        document.getElementById('gridStatus').textContent = state.settings.gridSnap ? 'ON' : 'OFF';
        document.getElementById('gridToggleText').textContent = state.settings.gridSnap ? 'Hide Grid' : 'Show Grid';
    }

    function togglePlay() {
        isPlaying = !isPlaying;

        const playBtn = document.getElementById('playBtn');
        const playIcon = document.getElementById('playIcon');
        const playText = document.getElementById('playText');

        if (isPlaying) {
            playBtn.classList.add('playing');
            playIcon.innerHTML = '&#9632;';
            playText.textContent = 'Stop';

            if (!state.driverGearId && state.gears.length > 0) {
                // Auto-select first gear as driver if none selected
                setDriverGear(state.gears[0].id);
                showToast('First gear set as driver', 'info');
            }
        } else {
            playBtn.classList.remove('playing');
            playIcon.innerHTML = '&#9654;';
            playText.textContent = 'Play';
        }
    }

    function toggleDirection() {
        state.settings.spinDirection *= -1;

        const directionBtn = document.getElementById('directionBtn');
        if (state.settings.spinDirection === 1) {
            directionBtn.textContent = '↻';
            directionBtn.classList.remove('counterclockwise');
            directionBtn.title = 'Clockwise (click to change)';
        } else {
            directionBtn.textContent = '↺';
            directionBtn.classList.add('counterclockwise');
            directionBtn.title = 'Counter-clockwise (click to change)';
        }

        propagateRotation();
        window.isDirty = true;
        showToast(state.settings.spinDirection === 1 ? 'Clockwise' : 'Counter-clockwise', 'info');
    }

    function toggleDriver() {
        if (state.selectedGearId) {
            if (state.driverGearId === state.selectedGearId) {
                state.driverGearId = null;
                state.gears.forEach(g => g.rotationSpeed = 0);
            } else {
                setDriverGear(state.selectedGearId);
            }
            updateUI();
            window.isDirty = true;
        }
    }

    function deleteSelectedGear() {
        if (state.selectedGearId) {
            deleteGear(state.selectedGearId);
            updateUI();
            showToast('Gear deleted', 'info');
        }
    }

    function deleteSelectedOutput() {
        if (state.selectedOutputId) {
            const index = state.outputs.findIndex(o => o.id === state.selectedOutputId);
            if (index !== -1) {
                state.outputs.splice(index, 1);
                state.selectedOutputId = null;
                window.isDirty = true;
                showToast('Output deleted', 'info');
            }
        }
    }

    function toggleGrid() {
        state.settings.gridSnap = !state.settings.gridSnap;
        updateUI();
        window.isDirty = true;
    }

    function resetZoom() {
        zoom = 1;
        panX = 0;
        panY = 0;
        document.getElementById('zoomLevel').textContent = '100%';
    }

    function showSettingsModal() {
        // Update slider values to match current settings
        document.getElementById('thicknessSlider').value = state.settings.toothThickness * 100;
        document.getElementById('thicknessValue').textContent = Math.round(state.settings.toothThickness * 100) + '%';
        document.getElementById('depthSlider').value = state.settings.toothDepth;
        document.getElementById('depthValue').textContent = state.settings.toothDepth + 'px';

        document.getElementById('settingsModal').classList.add('visible');
    }

    function hideSettingsModal(event) {
        if (event && event.target !== event.currentTarget) return;
        document.getElementById('settingsModal').classList.remove('visible');
    }

    function updateThicknessSetting(value) {
        state.settings.toothThickness = value / 100;
        document.getElementById('thicknessValue').textContent = value + '%';
        window.isDirty = true;
    }

    function updateDepthSetting(value) {
        state.settings.toothDepth = parseInt(value);
        document.getElementById('depthValue').textContent = value + 'px';
        window.isDirty = true;
    }

    // Help Modal Functions
    function showHelpModal(topic) {
        const content = helpContent[topic];
        if (!content) return;

        document.getElementById('helpModalTitle').textContent = content.title;
        document.getElementById('helpModalContent').innerHTML = content.content;
        document.getElementById('helpModal').classList.add('visible');
    }

    function hideHelpModal(event) {
        if (event && event.target !== event.currentTarget) return;
        document.getElementById('helpModal').classList.remove('visible');
    }

    function clearAll() {
        if (state.gears.length === 0) return;

        if (confirm('Clear all gears? This cannot be undone.')) {
            state.gears = [];
            state.outputs = [];
            state.driverGearId = null;
            state.selectedGearId = null;
            updateUI();
            window.isDirty = true;
            showToast('All gears cleared', 'info');
        }
    }

    function resetRotations() {
        state.gears.forEach(g => g.rotation = 0);
        state.outputs.forEach(o => o.rotation = 0);
        showToast('Rotations reset', 'info');
    }

    function newProject() {
        if (window.isDirty) {
            if (!confirm('You have unsaved changes. Start a new project anyway?')) {
                return;
            }
        }
        window.location.href = '?';
    }

    function exportImage() {
        const link = document.createElement('a');
        link.download = 'gears-project.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
        showToast('Image exported!', 'success');
    }

    // ============================================
    // Save/Load Functions
    // ============================================
    function serializeProject() {
        return {
            version: '1.0',
            settings: state.settings,
            gears: state.gears.map(g => ({
                id: g.id,
                x: g.x,
                y: g.y,
                teethCount: g.teethCount,
                color: g.color,
                rotation: g.rotation,
                phaseOffset: g.phaseOffset,
                // Save attached image data (without imageObj - that gets reloaded)
                attachedImage: g.attachedImage ? {
                    url: g.attachedImage.url,
                    offsetX: g.attachedImage.offsetX,
                    offsetY: g.attachedImage.offsetY,
                    scale: g.attachedImage.scale
                } : null
            })),
            outputs: state.outputs.map(o => ({
                id: o.id,
                type: o.type,
                x: o.x,
                y: o.y,
                attachedToGear: o.attachedToGear,
                color: o.color
            })),
            driverGearId: state.driverGearId
        };
    }

    function saveProject() {
        const projectData = JSON.stringify(serializeProject());

        if (!currentProjectId) {
            // Create new project
            fetch('https://www.mytekos.com/beta/api/v1/projects/create', {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'include',
                body: JSON.stringify({
                    application_id: APPLICATION_ID.toString(),
                    name: 'gears_' + Date.now()
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.project_id) {
                    currentProjectId = data.project_id;
                    saveProjectData(projectData);
                    // Redirect to include project ID
                    window.location.href = '?id=' + data.project_id;
                } else {
                    showToast('Failed to create project', 'error');
                }
            })
            .catch(err => {
                console.error('Create error:', err);
                showToast('Failed to create project', 'error');
            });
        } else {
            saveProjectData(projectData);
        }
    }

    function saveProjectData(projectData) {
        fetch(`https://www.mytekos.com/beta/api/v1/files/${currentProjectId}/update`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',
            body: JSON.stringify({
                project_id: currentProjectId,
                content: projectData
            })
        })
        .then(response => response.json())
        .then(data => {
            window.isDirty = false;
            showToast('Project saved!', 'success');
            // Save screenshot for gallery preview
            saveScreenshot();
        })
        .catch(err => {
            console.error('Save error:', err);
            showToast('Failed to save project', 'error');
        });
    }

    function saveScreenshot() {
        if (!currentProjectId || !canvas) return;

        // Create a temporary canvas for the screenshot
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');

        // Set screenshot size (smaller for preview)
        const screenshotWidth = 400;
        const screenshotHeight = 300;
        tempCanvas.width = screenshotWidth;
        tempCanvas.height = screenshotHeight;

        // Fill background
        tempCtx.fillStyle = state.settings.backgroundColor;
        tempCtx.fillRect(0, 0, screenshotWidth, screenshotHeight);

        // Calculate bounds of all gears to center them
        if (state.gears.length === 0) return;

        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;
        const toothDepth = state.settings.toothDepth;

        state.gears.forEach(gear => {
            const r = gear.radius + toothDepth + 5;
            minX = Math.min(minX, gear.x - r);
            maxX = Math.max(maxX, gear.x + r);
            minY = Math.min(minY, gear.y - r);
            maxY = Math.max(maxY, gear.y + r);
        });

        const contentWidth = maxX - minX;
        const contentHeight = maxY - minY;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;

        // Calculate scale to fit with padding
        const padding = 20;
        const scaleX = (screenshotWidth - padding * 2) / contentWidth;
        const scaleY = (screenshotHeight - padding * 2) / contentHeight;
        const scale = Math.min(scaleX, scaleY, 2);

        // Draw gears centered
        tempCtx.save();
        tempCtx.translate(screenshotWidth / 2, screenshotHeight / 2);
        tempCtx.scale(scale, scale);
        tempCtx.translate(-centerX, -centerY);

        // Draw each gear (simplified version)
        state.gears.forEach(gear => {
            drawGearToContext(tempCtx, gear);
        });

        tempCtx.restore();

        // Convert to base64 and save
        const imgData = tempCanvas.toDataURL('image/png');

        fetch('/beta/applications/Gears/save_screenshot.php', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',
            body: JSON.stringify({
                project_id: currentProjectId,
                img_data: imgData
            })
        })
        .then(response => response.json())
        .then(data => {
            if (!data.success) {
                console.error('Screenshot save failed:', data.error);
            }
        })
        .catch(err => {
            console.error('Screenshot error:', err);
        });
    }

    // Draw gear to a specific context (for screenshots)
    function drawGearToContext(ctx, gear) {
        const toothDepth = state.settings.toothDepth;
        const toothWidthFactor = state.settings.toothThickness;
        const taperRatio = 0.65;

        ctx.save();
        ctx.translate(gear.x, gear.y);
        ctx.rotate(gear.rotation);

        const angularPitch = (Math.PI * 2) / gear.teethCount;
        const outerRadius = gear.radius + toothDepth;
        const innerRadius = gear.radius - toothDepth * 1.2;
        const baseHalfWidth = angularPitch * toothWidthFactor / 2;
        const tipHalfWidth = baseHalfWidth * taperRatio;

        ctx.beginPath();
        for (let i = 0; i < gear.teethCount; i++) {
            const toothCenter = i * angularPitch;
            const tipStart = toothCenter - tipHalfWidth;
            const tipEnd = toothCenter + tipHalfWidth;
            const baseEnd = toothCenter + baseHalfWidth;
            const valleyEnd = toothCenter + angularPitch - baseHalfWidth;
            const nextTipStart = toothCenter + angularPitch - tipHalfWidth;

            if (i === 0) {
                ctx.moveTo(Math.cos(tipStart) * outerRadius, Math.sin(tipStart) * outerRadius);
            }
            ctx.lineTo(Math.cos(tipEnd) * outerRadius, Math.sin(tipEnd) * outerRadius);
            ctx.lineTo(Math.cos(baseEnd) * innerRadius, Math.sin(baseEnd) * innerRadius);
            ctx.lineTo(Math.cos(valleyEnd) * innerRadius, Math.sin(valleyEnd) * innerRadius);
            ctx.lineTo(Math.cos(nextTipStart) * outerRadius, Math.sin(nextTipStart) * outerRadius);
        }
        ctx.closePath();

        // Fill gear
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, gear.radius);
        gradient.addColorStop(0, lightenColor(gear.color, 30));
        gradient.addColorStop(1, gear.color);
        ctx.fillStyle = gradient;
        ctx.fill();
        ctx.strokeStyle = darkenColor(gear.color, 30);
        ctx.lineWidth = 2;
        ctx.stroke();

        // Center hole
        ctx.beginPath();
        ctx.arc(0, 0, 8, 0, Math.PI * 2);
        ctx.fillStyle = state.settings.backgroundColor;
        ctx.fill();

        // Center axle
        ctx.beginPath();
        ctx.arc(0, 0, 4, 0, Math.PI * 2);
        ctx.fillStyle = '#555';
        ctx.fill();

        // Draw attached image (for screenshot)
        if (gear.attachedImage && gear.attachedImage.imageObj) {
            const img = gear.attachedImage.imageObj;
            const scale = gear.attachedImage.scale || 1;
            const offsetX = gear.attachedImage.offsetX || 0;
            const offsetY = gear.attachedImage.offsetY || 0;

            const maxSize = gear.radius * 1.5;
            const aspectRatio = img.width / img.height;
            let drawWidth, drawHeight;

            if (aspectRatio > 1) {
                drawWidth = maxSize * scale;
                drawHeight = drawWidth / aspectRatio;
            } else {
                drawHeight = maxSize * scale;
                drawWidth = drawHeight * aspectRatio;
            }

            ctx.drawImage(
                img,
                offsetX - drawWidth / 2,
                offsetY - drawHeight / 2,
                drawWidth,
                drawHeight
            );
        }

        ctx.restore();
    }

    function autoSave() {
        if (currentProjectId && window.isDirty) {
            const projectData = JSON.stringify(serializeProject());

            fetch(`https://www.mytekos.com/beta/api/v1/files/${currentProjectId}/update`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'include',
                body: JSON.stringify({
                    project_id: currentProjectId,
                    content: projectData
                })
            })
            .then(response => response.json())
            .then(data => {
                window.isDirty = false;
                showToast('Auto-saved', 'success');
            })
            .catch(err => {
                console.error('Auto-save error:', err);
            });
        }
    }

    // ============================================
    // Toast Notification
    // ============================================
    function showToast(message, type = 'info') {
        const toast = document.createElement('div');
        toast.className = 'toast ' + type;
        toast.textContent = message;
        document.body.appendChild(toast);

        setTimeout(() => {
            toast.style.opacity = '0';
            toast.style.transform = 'translateX(100%)';
            setTimeout(() => toast.remove(), 300);
        }, 2000);
    }

    // ============================================
    // Initialize
    // ============================================
    // Export for platform adapter
    window.serializeProjectData = serializeProject;
    window.loadProjectData = loadProjectData;
    window.markDirty = function() { window.isDirty = true; };
    window.markClean = function() { window.isDirty = false; };
    window.hasUnsavedChanges = function() { return window.isDirty; };

    window.addEventListener('load', init);

    // beforeunload handled by platform adapter
    </script>
</body>
</html>
